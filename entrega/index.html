<!doctype html>
<html lang='pt-br'>
<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <title>MiniCoin - Entrega</title>
  <link rel='stylesheet' href='styles.css'>
</head>
<body>
<header class='topbar'>
  <div class='container'>
    <h1>MiniCoin - Uma Moeda Virtual Baseada em Blockchain</h1>
    <p class='subtitle'>Trabalho Prático de Redes II</p>
    <p class='meta'>Autores: João Meyer e Vitor Faria</p>
  </div>
</header>

<main class='container'>

  <!-- CARD 1: RELATÓRIO DETALHADO -->
  <section class='card' id='relatorio'>
    <h2>Relatório</h2>

    <h3>1. Visão geral</h3>
    <p>
      O MiniCoin implementa uma moeda virtual didática com servidor TCP concorrente e um
      cliente interativo (REPL). Cada conta possui uma blockchain simplificada mantida em memória:
      uma lista encadeada de registros (blocos) com encadeamento por <code>prev_hash</code> e validação de integridade via
      <code>SHA-256</code> do payload canônico. As respostas do servidor são sempre JSON por linha.
    </p>

    <h3>2. Fluxo de uma sessão típica</h3>
<pre class='diagram'>
[Cliente REPL]                  [Servidor MiniCoin]
    |                                  |
    | conectar ----------------------> | envia banner: {"ok": true, "message": "..."}
    | comando em texto --------------> | parse + dispatch do comando
    |                                  | valida integridade/saldo/entradas
    |                                  | executa operação (locks + atualização)
    | <------------------------------- | JSON por linha com {ok, ...}
    | repetir até QUIT                 | encerra conexão
</pre>

    <h3>3. Protocolo</h3>
    <p>
      Comunicação linha-a-linha em TCP persistente. O cliente envia uma linha de texto por comando.
      O servidor responde com um JSON em uma única linha contendo a chave <code>ok</code> e os dados da resposta
      (ex.: <code>{'ok': true, 'owner': 'joaozinho', 'balance': 130}</code>). Em erros, <code>ok=false</code> e um campo <code>error</code>.
    </p>

    <h3>4. Estrutura de dados do bloco</h3>
    <p>
      Cada bloco guarda <code>operation</code> (GENESIS, DEPOSIT, WITHDRAW), <code>amount</code>,
      <code>timestamp</code>, <code>owner?</code> (apenas no gênese), <code>prev_hash</code>, <code>curr_hash</code> e o ponteiro <code>next</code>.
      O <code>curr_hash</code> é calculado sobre o JSON canônico do payload
      (ordem de chaves fixa + separadores enxutos). O gênese usa <code>prev_hash = '0'*64</code>.
    </p>
    <ul>
      <li>Invariantes: para todo bloco i, <code>prev_hash[i] = curr_hash[i-1]</code>; <code>curr_hash</code> confere com o payload.</li>
      <li>Saldo: acumulado por cadeia para leitura O(1).</li>
      <li>Iteração: utilitários para percorrer e materializar a cadeia em lista para o comando <code>CHAIN</code>.</li>
    </ul>

    <h3>5. Concorrência e atomicidade</h3>
    <ul>
      <li>Mapa de contas: protegido por <code>ACCOUNTS_LOCK</code> (RLock) para criar/obter cadeias.</li>
      <li>Cadeia por conta: cada conta possui um <code>RLock</code> próprio; operações adquirem o lock da conta.</li>
      <li>Transferência: bloqueia as duas cadeias em ordem determinística (por nome do owner) para evitar deadlock;
        verifica integridade de ambas; desconta do remetente e credita no destinatário atomicamente.</li>
      <li>Integridade antes de mutar: <code>deposit()</code> e <code>withdraw()</code> chamam verificação de integridade
        antes de alterar o estado; <code>withdraw()</code> falha se saldo insuficiente.</li>
    </ul>

    <h3>6. Comandos</h3>
    <p>
      <code>HELP</code>, <code>INIT &lt;owner&gt; &lt;initial&gt;</code>, <code>DEPOSIT &lt;owner&gt; &lt;amount&gt;</code>,
      <code>WITHDRAW &lt;owner&gt; &lt;amount&gt;</code>, <code>BALANCE &lt;owner&gt;</code>, <code>CHAIN &lt;owner&gt;</code>,
      <code>VERIFY &lt;owner&gt;</code>, <code>TRANSFER &lt;from&gt; &lt;to&gt; &lt;amount&gt;</code>, <code>ACCOUNTS</code>, <code>QUIT</code>.
    </p>

    <h3>7. Casos de teste</h3>
    <ul>
      <li>Criação: <code>INIT maria 100</code> e <code>INIT joao 50</code>.</li>
      <li>Depósito: <code>DEPOSIT maria 40</code>.</li>
      <li>Saque válido: <code>WITHDRAW joao 10</code>.</li>
      <li>Transferência: <code>TRANSFER maria joao 60</code>.</li>
      <li>Verificação: <code>VERIFY maria</code> e <code>VERIFY joao</code>.</li>
      <li>Erros: depósito negativo, saldo insuficiente e conta inexistente.</li>
    </ul>

    <h3>8. Limitações</h3>
    <ul>
      <li>Sem persistência em disco; dados voláteis em memória.</li>
      <li>Inteiros positivos; sem segurança de transporte (TLS) e sem autenticação.</li>
      <li>Servidor único mantendo todas as cadeias.</li>
    </ul>

    <h3>9. Escolhas de projeto</h3>
    <ul>
      <li>Protocolo texto linha-a-linha para facilitar testes com ferramentas simples e depuração.</li>
      <li>Respostas em JSON em uma única linha para consumo fácil por scripts e clientes diversos.</li>
      <li>Blockchain em memória usando lista encadeada para clareza e custo de implementação baixo.</li>
      <li>Timestamp em formato ISO-8601 para registros consistentes.</li>
      <li>Verificação de integridade obrigatória antes de operações que mudam entre estados.</li>
    </ul>
  </section>

  <!-- CARD 2: LOGS -->
  <section class='card' id='logs'>
    <h2>Logs de execução</h2>

    <h3>Servidor</h3>
    <pre id='logs-servidor'>
=====================================
inicio da execucao: servidor MiniCoin
=====================================
MiniCoin TCP server em 127.0.0.1:9090

inseri conta 'maria' com deposito inicial = 100
contas ativas: [ maria ]
veja a cadeia de 'maria': [ 0 ]
inseri conta 'joao' com deposito inicial = 50
contas ativas: [ joao maria ]
veja a cadeia de 'joao': [ 0 ]
contas ativas: [ joao maria ]
erro: erro ao depositar em 'joao': deposito deve ser > 0
    </pre>

    <h3>Cliente</h3>
    <pre id='logs-cliente'>
{"ok": true, "message": "MiniCoin TCP pronto. Use HELP."}
minicoin> INIT maria 100
{"ok": true, "owner": "maria", "balance": 100}
minicoin> INIT joao 50
{"ok": true, "owner": "joao", "balance": 50}
minicoin> DEPOSIT maria 40
{"ok": true, "owner": "maria", "balance": 140}
minicoin> WITHDRAW joao 10
{"ok": true, "owner": "joao", "balance": 40, "message": "retirada efetuada"}
minicoin> BALANCE maria
{"ok": true, "owner": "maria", "balance": 140}
minicoin> BALANCE joao
{"ok": true, "owner": "joao", "balance": 40}
minicoin> TRANSFER maria joao 60
{"ok": true, "message": "transferencia concluida", "balance_src": 80, "balance_dst": 100}
minicoin> BALANCE maria
{"ok": true, "owner": "maria", "balance": 80}
minicoin> BALANCE joao
{"ok": true, "owner": "joao", "balance": 100}
minicoin> VERIFY maria
{"ok": true, "owner": "maria", "index": null, "reason": null}
minicoin> VERIFY joao
{"ok": true, "owner": "joao", "index": null, "reason": null}
minicoin> CHAIN maria
{"ok": true, "owner": "maria", "chain": [{"index": 0, "operation": "GENESIS", "owner": "maria", "amount": 100, "timestamp": "...", "prev_hash": "000...", "curr_hash": "84b..."}, {"index": 1, "operation": "DEPOSIT", "owner": null, "amount": 40, "timestamp": "...", "prev_hash": "84b...", "curr_hash": "c4d..."}, {"index": 2, "operation": "WITHDRAW", "owner": null, "amount": 60, "timestamp": "...", "prev_hash": "c4d...", "curr_hash": "b8d..."}]}
minicoin> CHAIN joao
{"ok": true, "owner": "joao", "chain": [{"index": 0, "operation": "GENESIS", "owner": "joao", "amount": 50, "timestamp": "...", "prev_hash": "000...", "curr_hash": "dc2..."}, {"index": 1, "operation": "WITHDRAW", "owner": null, "amount": 10, "timestamp": "...", "prev_hash": "dc2...", "curr_hash": "321..."}, {"index": 2, "operation": "DEPOSIT", "owner": null, "amount": 60, "timestamp": "...", "prev_hash": "321...", "curr_hash": "901..."}]}
minicoin> ACCOUNTS
{"ok": true, "owners": ["joao", "maria"]}
minicoin> WITHDRAW maria 999
{"ok": false, "owner": "maria", "balance": 80, "message": "saldo insuficiente"}
minicoin> DEPOSIT joao -5
{"ok": false, "error": "deposito deve ser > 0"}
minicoin> TRANSFER maria joao 0
{"ok": false, "message": "amount deve ser > 0", "balance_src": 80, "balance_dst": 100}
minicoin> BALANCE carlos
{"ok": false, "error": "conta 'carlos' nao existe"}
minicoin> QUIT
{"ok": true, "message": "bye"}
    </pre>
  </section>

  <!-- CARD 3: CÓDIGO-FONTE -->
  <section class='card' id='codigo'>
    <h2>Código-fonte para download (.txt)</h2>
    <p>Arquivos disponibilizados em <code>.txt</code></p>
    <ul class='downloads'>
      <li><a href='client.py.txt' download>client.py.txt</a> - cliente TCP interativo</li>
      <li><a href='server.py.txt' download>server.py.txt</a> - servidor MiniCoin (blockchain)</li>
    </ul>
  </section>

</main>
</body>
</html>
